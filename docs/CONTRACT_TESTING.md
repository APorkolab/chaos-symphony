# Contract Testing in Chaos Symphony

This document explains the contract testing implementation using Pact for ensuring compatibility between microservices.

## Overview

Contract testing ensures that services can communicate with each other by defining and verifying the contracts (message formats) between them. In Chaos Symphony, we use [Pact](https://pact.io/) for message-based contract testing.

## Implementation

### Consumer Tests (Orchestrator)

The `orchestrator` service acts as a **consumer** of payment services and defines the expected message formats.

**Location**: `orchestrator/src/test/java/hu/porkolab/chaosSymphony/orchestrator/pact/PaymentSvcContractTest.java`

```java
@Pact(consumer = "orchestrator")
public MessagePact createPaymentRequestedPact(MessagePactBuilder builder) {
    return builder
            .expectsToReceive("A payment requested event")
            .withContent(newJsonBody(envelope -> {
                envelope.stringType("orderId", "e7a4f431-b2e3-4b43-8a24-8e2b1d3a0e46");
                envelope.stringType("eventId", "f8b5c2d1-3e4f-5a6b-7c8d-9e0f1a2b3c4d");
                envelope.stringType("type", "PaymentRequested");
                envelope.stringType("payload", "{\"orderId\":\"...\",\"amount\":123.45,\"currency\":\"USD\"}");
            }).build())
            .toPact();
}
```

This test:
1. Defines the expected envelope structure for payment requests
2. Specifies the payload format including orderId, amount, and currency
3. Generates a `.json` contract file in `target/pacts/`

### Provider Tests (Payment Service)

The `payment-svc` acts as a **provider** and verifies it can handle the contracts defined by consumers.

**Location**: `payment-svc/src/test/java/hu/porkolab/chaosSymphony/payment/contract/PaymentSvcPactVerificationTest.java`

```java
@PactVerifyProvider("A payment requested event")
public MessageAndMetadata verifyPaymentRequestedMessage() throws Exception {
    String orderId = "e7a4f431-b2e3-4b43-8a24-8e2b1d3a0e46";
    String eventId = "f8b5c2d1-3e4f-5a6b-7c8d-9e0f1a2b3c4d";
    
    String paymentPayload = objectMapper.createObjectNode()
            .put("orderId", orderId)
            .put("amount", 123.45)
            .put("currency", "USD")
            .toString();
    
    String envelopedMessage = EnvelopeHelper.envelope(orderId, eventId, "PaymentRequested", paymentPayload);
    
    return new MessageAndMetadata(
        envelopedMessage.getBytes(),
        Map.of("content-type", "application/json")
    );
}
```

This test:
1. Reads the contract generated by the consumer
2. Verifies the provider can generate messages matching the contract
3. Ensures the `EnvelopeHelper` and message format are compatible

## Message Format

All messages use the envelope pattern defined in `common-messaging`:

```json
{
  "orderId": "string",
  "eventId": "string", 
  "type": "PaymentRequested|PaymentResult|...",
  "payload": "{JSON payload as string}"
}
```

### Payment Request Payload
```json
{
  "orderId": "uuid",
  "amount": 123.45,
  "currency": "USD"
}
```

### Payment Result Payload
```json
{
  "orderId": "uuid",
  "status": "CHARGED|FAILED",
  "amount": 123.45
}
```

## Running Contract Tests

### Automated Script
```bash
# From project root
./scripts/run-contract-tests.sh
```

### Manual Steps
```bash
# 1. Generate consumer contracts
cd orchestrator
mvn test -Dtest="*Pact*Test"

# 2. Verify provider can handle contracts
cd ../payment-svc  
mvn test -Dtest="*PactVerificationTest"
```

### CI Integration

The contract tests are integrated into the CI pipeline:

```yaml
# In .github/workflows/ci.yml
- name: Build, Test, and Dependency Check
  run: mvn -U -B clean verify -DskipITs=false
```

The `verify` phase includes contract test execution.

## Contract Evolution

### Breaking Changes

If a service needs to change its message format:

1. **Consumer** updates the contract test with new format
2. **Provider** updates implementation to handle new format  
3. Both tests must pass before deployment

### Backward Compatibility

For backward-compatible changes:
1. Provider implements support for both old and new formats
2. Consumer gradually migrates to new format
3. Old format support is removed after migration

## Benefits

✅ **Early Detection**: Contract breaks are caught before deployment
✅ **Documentation**: Contracts serve as living documentation  
✅ **Confidence**: Safe refactoring and deployment
✅ **Decoupling**: Services can develop independently
✅ **Versioning**: Clear evolution path for APIs

## Best Practices

1. **Run contract tests in CI** - Catch breaking changes early
2. **Version your contracts** - Use semantic versioning for major changes
3. **Consumer-driven** - Let consumers define what they need
4. **Test realistic data** - Use production-like test data
5. **Fail fast** - Contract failures should stop the build

## Troubleshooting

### Common Issues

**Contract file not found**: Ensure consumer tests run before provider tests
**Message format mismatch**: Check EnvelopeHelper usage matches between services  
**Build failures**: Verify all dependencies in common-messaging are properly included

### Debug Mode

Enable detailed logging:
```yaml
logging:
  level:
    au.com.dius.pact: DEBUG
```

## Future Enhancements

- **Pact Broker**: Centralized contract storage and versioning
- **Can I Deploy**: Automated deployment safety checks
- **More Services**: Extend contracts to inventory-svc and shipping-svc
- **HTTP Contracts**: Add REST API contract testing
